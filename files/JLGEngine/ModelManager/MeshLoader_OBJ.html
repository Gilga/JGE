<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeshLoader_OBJ.jl · JGE</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JGE</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../manual/start.html">Start</a></li></ul></li><li><span class="toctext">Source Files</span><ul><li><a class="toctext" href="../../App.html">App.jl</a></li><li><a class="toctext" href="../../CoreExtended.html">CoreExtended.jl</a></li><li><a class="toctext" href="../../Environment.html">Environment.jl</a></li><li><a class="toctext" href="../../FileManager.html">FileManager.jl</a></li><li><a class="toctext" href="../../JLScriptManager.html">JLScriptManager.jl</a></li><li><a class="toctext" href="../../LoggerManager.html">LoggerManager.jl</a></li><li><a class="toctext" href="../../MatrixMath.html">MatrixMath.jl</a></li><li><a class="toctext" href="../../RessourceManager.html">RessourceManager.jl</a></li><li><a class="toctext" href="../../ThreadFunctions.html">ThreadFunctions.jl</a></li><li><a class="toctext" href="../../ThreadManager.html">ThreadManager.jl</a></li><li><a class="toctext" href="../../TimeManager.html">TimeManager.jl</a></li><li><a class="toctext" href="../../WindowManager.html">WindowManager.jl</a></li><li><a class="toctext" href="../../JLGEngine.html">JLGEngine.jl</a></li><li><a class="toctext" href="../CameraManager.html">CameraManager.jl</a></li><li><a class="toctext" href="../ChunkManager.html">ChunkManager.jl</a></li><li><a class="toctext" href="../EntityManager.html">EntityManager.jl</a></li><li><a class="toctext" href="../GameObjectManager.html">GameObjectManager.jl</a></li><li><a class="toctext" href="../GraphicsManager.html">GraphicsManager.jl</a></li><li><a class="toctext" href="../Management.html">Management.jl</a></li><li><a class="toctext" href="../MeshManager.html">MeshManager.jl</a></li><li><a class="toctext" href="../ModelManager.html">ModelManager.jl</a></li><li><a class="toctext" href="../RenderManager.html">RenderManager.jl</a></li><li><a class="toctext" href="../ShaderManager.html">ShaderManager.jl</a></li><li><a class="toctext" href="../StorageManager.html">StorageManager.jl</a></li><li><a class="toctext" href="../SzeneManager.html">SzeneManager.jl</a></li><li><a class="toctext" href="../TextureManager.html">TextureManager.jl</a></li><li><a class="toctext" href="../TransformManager.html">TransformManager.jl</a></li><li><a class="toctext" href="MeshData.html">MeshData.jl</a></li><li><a class="toctext" href="MeshFabric.html">MeshFabric.jl</a></li><li class="current"><a class="toctext" href="MeshLoader_OBJ.html">MeshLoader_OBJ.jl</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Parse-triples:-i,-i/j/k,-i//k,-i/j-1">Parse triples: i, i/j/k, i//k, i/j```</a></li></ul></li><li><a class="toctext" href="../LibGL/LibGL.html">LibGL.jl</a></li><li><a class="toctext" href="../LibGL/GLDebugControl.html">GLDebugControl.jl</a></li><li><a class="toctext" href="../LibGL/GLExtendedFunctions.html">GLExtendedFunctions.jl</a></li><li><a class="toctext" href="../LibGL/GLLists.html">GLLists.jl</a></li><li><a class="toctext" href="../LibGL/GLSLParser.html">GLSLParser.jl</a></li><li><a class="toctext" href="../LibGL/GLSLRessources.html">GLSLRessources.jl</a></li><li><a class="toctext" href="../LibGL/ShaderManager.html">GL/ShaderManager.jl</a></li><li><a class="toctext" href="../LibGL/StorageManager.html">GL/StorageManager.jl</a></li><li><a class="toctext" href="../LibGL/TextureManager.html">GL/TextureManager.jl</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Source Files</li><li><a href="MeshLoader_OBJ.html">MeshLoader_OBJ.jl</a></li></ul><a class="edit-page" href="https://github.com/Gilga/JGE/blob/master/doc/src/files/JLGEngine/ModelManager/MeshLoader_OBJ.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MeshLoader_OBJ.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="MeshLoader_OBJ.jl-1" href="#MeshLoader_OBJ.jl-1">MeshLoader_OBJ.jl</a></h1><pre><code class="language-none">type ShapeCoordinates
	#std::string&amp; name
	positions::AVec3f
	normals::AVec3f
	texcoords::AVec2f
	indicies::AIndex
	origin::Vec3f
	scale::Vec3f

	ShapeCoordinates() = new(AVec3f(),AVec3f(),AVec1f(),AIndex(),Vec3f(),Vec3f())
	ShapeCoordinates(positions,normals,texcoords,indicies,origin,scale) = new(positions,normals,texcoords,indicies,origin,scale)
end</code></pre><pre><code class="language-none">type VertexIndex
	v::Integer
	vt::Integer
	vn::Integer

	VertexIndex() = new(0,0,0)
	VertexIndex(a::Integer) = new(a,a,a)
	VertexIndex(v::Integer, vn::Integer, vt::Integer) = new(v,vt,vn)
end

AVertexIndex = Array{VertexIndex,1}
AAVertexIndex = Array{AVertexIndex,1}
AGroupIndex = Array{Array{Array{Integer,1},1},1}</code></pre><pre><code class="language-none">function clear(sc::ShapeCoordinates)
	sc.positions = AVec3f()
	sc.normals = AVec3f()
	sc.texcoords = AVec1f()
	sc.indicies = AIndex()
	sc.origin = Vec3f()
	sc.scale = Vec3f()
end

# for std::map```
</code></pre><p>function isSmaller(a::VertexIndex, b::VertexIndex) 	if a.v != b.v return (a.v &lt; b.v) end 	if a.vn != b.vn return (a.vn &lt; b.vn) end 	if a.vt != b.vt return (a.vt &lt; b.vt) end 	false end</p><pre><code class="language-none"></code></pre><p>isSpace(c::Char) = (c == &#39; &#39;) || (c == &#39;\t&#39;)</p><pre><code class="language-none"></code></pre><p>isNewLine(c::Char) = (c == &#39;\r&#39;) || (c == &#39;\n&#39;) || (c == &#39;\0&#39;)</p><pre><code class="language-none"></code></pre><p>function getOrigin(min_BBOX::Vec3f, max_BBOX::Vec3f, scale::Number) 	(max_BBOX + min_BBOX) * (scale * 0.5f0) end</p><pre><code class="language-none"></code></pre><p>function getScale(min_BBOX::Vec3f, max_BBOX::Vec3f) 	size = max_BBOX - min_BBOX 	println(&quot;size: &quot;,size) 	scale_value = size.x &gt; size.z ? size.x : size.z 	println(&quot;1scale_value: &quot;,scale_value) 	scale_value = scale_value &gt; size.y ? scale_value : size.y 	println(&quot;2scale_value: &quot;,scale_value) 	scale_value = abs(scale_value) 	println(&quot;3scale_value: &quot;,scale_value) 	if scale_value &gt; 1 scale_value = 1 / scale_value 	#if scale_value &gt; 0 &amp;&amp; scale_value &lt; 1 scale_value = scale_value 	else scale_value = 1 	end 	scale_value end</p><p>#function parseval(T::DataType, str::String, start=1) #	t = search(str, r&quot;[+-]?[0-9]+(.[0-9]+)?&quot;, start) #	 ##	v = 0 #	try #		v = parse(T, str[t.start:t.stop]) ##	catch(e) #	end #	 #	(v, t.stop) #end</p><pre><code class="language-none"></code></pre><p>function parseVal(T::DataType, str::AbstractString, default=T(0)) 	try 		return parse(T, str) 	catch(e) 	end 	default end</p><p>#for m in eachmatch(Regex(&quot;([0-9]+) ([0-9]+) ([0-9]+)&quot;),&quot;1 2 3s&quot;) println(m.captures) end```</p><pre><code class="language-none">function parseArray(T::DataType, str::AbstractString)
	a = Array{T,1}()
	m = matchall(Regex(&quot;(^|(?&lt;=\\s))[+-]?([0-9]+[.])?[0-9]+([eE][-+]?[0-9]+)?((?=\\s)|\$)&quot;),str) # only valid: (space?)(number)(space?)
	#for x in m push!(a, parseval(T, x)) end
	map(x-&gt;parseVal(T,x),m)
end</code></pre><pre><code class="language-none">function parseVec(linenr::Number, str::AbstractString, count::Number)
	if count &lt; 1 error(&quot;count &lt; 1&quot;) end

	a = parseArray(Float32, str)
	len = length(a)
	
	if len != count	warn(linenr, &quot;: missmatch count: required=$count != found=$(length(a)) &quot;, str)	end

	# on count missmatch: just read until max(count) reachted
	v = zeros(Float32,count)
	for i=1:(len&gt;=count ? count : len) v[i]=a[i] end
	
	result = nothing
	if count == 1 result = Vec1f(v)
	elseif count == 2 result = Vec2f(v)
	elseif count == 3 result = Vec3f(v)
	elseif count == 4 result = Vec4f(v)
	else result = Vec{count, Float32}(v)
	end
	result
end

# Make index zero-base, and also support relative index.```
</code></pre><p>function parseIndex(str::AbstractString, n::Integer) 	#a = parseArray(Integer, str) 	i = parseVal(Int, str, -1) #length(a)&gt;0 ? a[1] : 0 	#if idx &gt;= 0 i = idx 	#else i = n + idx # negative value = relative 	#end 	i end</p><pre><code class="language-none"></code></pre><p>has(str::AbstractString, index::Integer, c::Char) = index&gt;0 &amp;&amp; index&lt;=length(str) &amp;&amp; str[index] == c</p><h1><a class="nav-anchor" id="Parse-triples:-i,-i/j/k,-i//k,-i/j-1" href="#Parse-triples:-i,-i/j/k,-i//k,-i/j-1">Parse triples: i, i/j/k, i//k, i/j```</a></h1><pre><code class="language-none">function parseTriple(line::AbstractString, vsize::Integer, vnsize::Integer, vtsize::Integer)
	vi = VertexIndex()

	tmp = line
	vi.v = parseIndex(tmp, vsize)
	token = search(tmp, r&quot;[/\s]&quot;).start
	if !has(line,token,&#39;/&#39;) return vi end
	token+=1

	# i//k
	if has(line,token,&#39;/&#39;)
		token+=1
		tmp = line[token:end]
		vi.vn = parseIndex(tmp, vnsize)
		token = search(tmp, r&quot;/\s&quot;).start
		return vi
	end

	# i/j/k or i/j
	tmp = line[token:end]
	vi.vt = parseIndex(tmp, vtsize)
	token = search(tmp, r&quot;[/\s]&quot;).start
	
	if !has(line,token,&#39;/&#39;) return vi
	else token+=1  # skip &#39;/&#39;
	end
	
	tmp = line[token:end]
	vi.vn = parseIndex(tmp, vnsize)
	token = search(tmp, r&quot;[/\s]&quot;).start
	vi
end</code></pre><pre><code class="language-none">function updateVertex2(vi::VertexIndex, vCache::Dict{VertexIndex, Integer}, coord::ShapeCoordinates, cache::ShapeCoordinates)
	if haskey(vCache, vi) return vCache[vi] end

	if vi.v &gt; 0 &amp;&amp; vi.v &gt; length(coord.positions)
		error(&quot;$(vi.v) &gt; $(length(coord.positions))&quot;)
		return 0
	end

	v = coord.positions[vi.v]
	println(&quot;push position &quot;, v)
	push!(cache.positions, v) #MatrixMath.scale(v,coord.scale) - coord.origin)

	if vi.vn &gt; 0
		v = coord.normals[vi.vn]
		println(&quot;push normal &quot;, v)
		push!(cache.normals, v)
	end

	if vi.vt &gt; 0
		v = coord.texcoords[vi.vt]
		println(&quot;push texcoord &quot;, v)
		push!(cache.texcoords, v)
	end

	idx = length(cache.positions)
	vCache[vi] = idx
	idx
end

const MinUInt32 = UInt32(0)
const MaxUInt32 = UInt32(2^32 - 1)</code></pre><pre><code class="language-none">correctVec(v::Vec3f, tmp::ShapeCoordinates) = MatrixMath.scale(v, tmp.scale) #MatrixMath.scale(v, tmp.scale) - tmp.origin</code></pre><pre><code class="language-none">function parseAll(
	vCache::Dict{VertexIndex,Integer},
	groups::AGroupIndex,
	#const int material_id,
	#const std::string &amp;name,
	#bool clearCache,
	tmp::ShapeCoordinates,
	cache::ShapeCoordinates)
	
	clear(cache) # remove old

	cache.positions = map(x-&gt;correctVec(x, tmp),tmp.positions)
	cache.normals = tmp.normals
	cache.texcoords = tmp.texcoords
	
	for gs in groups
		for g in gs
			for index in g
				index += -1 #fix: index in file starts with 1 (not 0)
				index = index &lt; MinUInt32 || index &gt; MaxUInt32 ? MaxUInt32 : index
				push!(cache.indicies, UInt32(index))
				break # take only vertex indicies
			end
		end
	end

	# Flatten vertices and indices
	#=
	if length(group) &lt; 1
		warn(&quot;group: $(length(group))&quot;)
		return false
	end
	
	println(&quot;indicies group $(length(group))&quot;)
	for i=1:length(group)
		face = group[i]

		i0 = face[1]
		i1 = VertexIndex()
		i2 = face[2]

		npolys = length(face)

		# Polygon -&gt; triangle fan conversion
		for k=3:npolys
			i1 = i2
			i2 = face[k]

			v0 = updateVertex(i0, vCache, sc, cache)
			v1 = updateVertex(i1, vCache, sc, cache)
			v2 = updateVertex(i2, vCache, sc, cache)

			println(&quot;push index &quot;, v0); push!(cache.indicies, v0)
			println(&quot;push index &quot;, v1); push!(cache.indicies, v1)
			println(&quot;push index &quot;, v2); push!(cache.indicies, v2)
		end
	end
	=#

	true
end</code></pre><pre><code class="language-none">function parseIndicies(tmp_vi::AAVertexIndex,tmp::ShapeCoordinates, cache::ShapeCoordinates)

	clear(cache) # remove old

	ig = 0
	iCount = length(tmp_vi)
	vCount = length(tmp.positions)
	vnCount = length(tmp.normals)
	vtCount = length(tmp.texcoords)

	if !iCount warn(&quot;No index coordinates! $tmp&quot;)	end

	if !vCount
		error(&quot;No vertex coordinates! $tmp&quot;)
		return false
	end

	# For each vertex of each triangle
	for it in tmp_vi
		ig+=1
		for jt in it
			vi = jt
			iv = vi.v
			ivn = vi.vn
			ivt = vi.vt

			if iv &gt; 0
				if iv &lt;= vCount
					push!(cache.positions, tmp.positions[iv])
				else
					error(&quot;Missmatch count of vertex coordinates! $ig ($iv &lt;= 0 or &gt;= $vCount).&quot;)
					return false
				end
			end

			if ivn &gt; 0
				if ivn &lt;= vnCount
					push!(cache.normals, tmp.normals[ivn])
				else
					error(&quot;Missmatch count of normal coordinates! $ig ($ivn &lt;= 0 or &gt;= $vnCount).&quot;)
					return false
				end
			end

			if ivt &gt; 0
				if ivt &lt;= vtCount
					push!(cache.texcoords, tmp.texcoords[ivt])
				else
					error(&quot;Missmatch count of texture coordinates! $ig ($ivt &lt;= 0 or &gt;= $vtCount).&quot;)
					return false
				end
			end
		end
	end

	vCount = length(cache.positions)
	vnCount = length(cache.normals)
	vtCount = length(cache.texcoords)

	if !vCount
		error(&quot;No vertex coordinates!&quot;)
		return false
	end

	if vnCount &gt; 0 &amp;&amp; vCount != vnCount
		error(&quot;Missmatch count of vertex and normal coordinates! ($vCount != $vnCount).&quot;)
		return false
	end

	if vtCount &gt; 0 &amp;&amp; vCount != vtCount
		error(&quot;Missmatch count of vertex and texture coordinates! ($vCount != $vtCount).&quot;)
		return false
	end

	true
end</code></pre><pre><code class="language-none">function loadOBJ(path::String, mesh::Mesh)
	println(&quot;Load OBJ file $path...&quot;);

	tmp_v = AVec3f()
	tmp_vn = AVec3f()
	tmp_vt = AVec2f()
	tmp_g = AGroupIndex()

	vertexCache = Dict{VertexIndex,Integer}()

	min_BBOX = zeros(Vec3f)
	max_BBOX = zeros(Vec3f)

	linenr = 0
	warn(string(&quot;read &quot;, path))
	open(path) do file
		content=readstring(file)
		content=Base.replace(content, &quot;\r&quot;, &quot;&quot;)
		content=Base.replace(content, &quot;\\\n&quot;, &quot;&quot;) #remove broken lines
		#content=string(content,&#39;\0&#39;)
		open(x -&gt; println(x, content), string(path, &quot;.cleaned&quot;), &quot;w+&quot;)
		for line in split(content,r&quot;\n&quot;)
			linenr += 1
			line = lstrip(line)
			len = length(line) #+remove r
			id = len

			if len == 0 || line == &quot;&quot; continue end
			
			token = search(line, r&quot;\s+&quot;).start
			if token &lt;= 0
				#error(string(linenr, &quot;: invalid token = &quot;, token))
				warn(string(linenr, &quot;: no separator -&gt; skip&quot;))
				continue
			end
			
			#println(string(linenr, &quot;: search...&quot;))

			first = line[1]
			second = len &gt; 1 ? line[2] : &quot;&quot;
			third = len &gt; 2 ? line[3] : &quot;&quot;

			if first == &#39;\0&#39; || first == &#39;#&#39; continue # skip line

			elseif first == &#39;v&#39; &amp;&amp; isSpace(second)
				part = line[token:end]
				#warn(string(linenr, &quot;: &quot;, line))
				v = parseVec(linenr, part, 3)

				# set bounding box
				if v.x &lt; min_BBOX.x min_BBOX.x = v.x end
				if v.y &lt; min_BBOX.y min_BBOX.y = v.y end
				if v.z &lt; min_BBOX.z min_BBOX.z = v.z end
				if v.x &gt; max_BBOX.x max_BBOX.x = v.x end
				if v.y &gt; max_BBOX.y max_BBOX.y = v.y end
				if v.z &gt; max_BBOX.z max_BBOX.z = v.z end

				push!(tmp_v,v)
				continue

			elseif first == &#39;v&#39; &amp;&amp; second == &#39;n&#39; &amp;&amp; isSpace(third)
				part = line[token:end]
				#warn(string(linenr, &quot;: &quot;, line))
				v = parseVec(linenr, part, 3)
				#push!(tmp_vn, v)
				continue

			elseif first == &#39;v&#39; &amp;&amp; second == &#39;t&#39; &amp;&amp; isSpace(third)
				part = line[token:end]
				#warn(string(linenr, &quot;: &quot;, line))
				v = parseVec(linenr, part, 2)
				#push!(tmp_vt,v)
				continue

			elseif first == &#39;f&#39; &amp;&amp; isSpace(second)

				token += 1
				part = line[token:end]
				#warn(string(linenr, &quot;: &quot;, line))
				
				group = map((p)-&gt;map(function(x)
					v=parseVal(UInt32,x, -1)
					#println(linenr, &quot;: index &quot;, part, &quot; =&gt; &quot;, v)
					v
				end,split(p, r&quot;/&quot;)),split(part, r&quot;\s+&quot;))
				
				#if j&gt;0
				#	println(&quot;=&gt; &quot;, vi)
				#	push!(group,vi)
				#end
				
				#max = length(a) #search(line[token:end],r&quot;[\n]&quot;).start
				#for i=1:max
				#	part = line[token:end]
				#	vi = parseTriple(part, Integer(round(length(tmp_v) / 3)), Integer(round(length(tmp_vn) / 3)), Integer(round(length(tmp_vt) / 2)))
				#	println(linenr, &quot;: index &quot;, part, &quot; =&gt; &quot;, vi)
				#	push!(group,vi)
				#	n = search(part, r&quot;[ \t]&quot;).start
				#	token += n
				#end

				push!(tmp_g, group)
			end
		end
	end

	scale_value = getScale(min_BBOX, max_BBOX)
	println(&quot;scale_value: &quot;,scale_value)
	tmp_sc = ShapeCoordinates( tmp_v, tmp_vn, tmp_vt, AIndex(), getOrigin(min_BBOX, max_BBOX, scale_value), Vec3f(scale_value) )
	cache = ShapeCoordinates()
	result = parseAll(vertexCache, tmp_g, tmp_sc, cache)

	if result
		#println(&quot;positions $(length(cache.positions)): &quot;, cache.positions)
		#println(&quot;normals $(length(cache.normals)): &quot;, cache.normals)			
		#println(&quot;texcoords $(length(cache.texcoords)): &quot;, cache.texcoords)
		#println(&quot;indicies $(length(cache.indicies)). &quot;, cache.indicies)
		
		MeshManager.update(mesh, :MODEL, ()-&gt;(:TRIANGLES, cache.positions,cache.normals,cache.texcoords,cache.indicies))
		#shape.material_ids.push_back(material_id);
		#shape.name = name;
		#if (clearCache)	vCache.clear();
		println(&quot;Finsihed loading OBJ file $path.&quot;)
	end

	result
end</code></pre><footer><hr/><a class="previous" href="MeshFabric.html"><span class="direction">Previous</span><span class="title">MeshFabric.jl</span></a><a class="next" href="../LibGL/LibGL.html"><span class="direction">Next</span><span class="title">LibGL.jl</span></a></footer></article></body></html>
